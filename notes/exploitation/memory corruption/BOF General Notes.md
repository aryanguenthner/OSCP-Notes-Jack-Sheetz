# Buffer Overrflows
> Tips and tricks to succesfully exploit buffer overflows on both Windows & Linux. Also included are a condensed version of my general notes on the topic. 

# Basic flow of a stack-based BOF
1. large buffer that causes overflow
2. EIP is taken over by overwriting the return address on the stack by appropriately modifying the buffer to correspong to the correct offset as the return address
3. a shellcode payload is put in the buffer with a NOP sled
4. target the return address instruction that can redirect the program to the injected payload

#### Checklist
- [ ] fuzz all inputs
- [ ] indentify the crash-causing buffer size
- [ ] find exact address of the writable area of memory with BST or unique pattern generation
- [ ] look for additional writable memory space, reverse shellcode typically needs 500-700 bytes
- [ ] check for bad characters
- [ ] identify all DLL's loaded with mona and find a DLL that satisfies the previously found requirements
- [ ] identify a JMP ESP instruction with msf-nasm_shell
- [ ] generate shellcode
	- [ ] Shikata Ga Nai encode to prevent bad characters
- [ ] nop sled to create to protect decoding
---- 
### General Notes
- Goal is to aim to write aribitrary code into the EIP register as this is the CPU register that stores the address of the next instruction to be executed
	- if we can overwite this address we can direct the program to execute code in any location we are able to overflow

- the ESP register stores the address of the current stack frame
	- basically is what controls the scope of local variables
	- common target for shellcode if EIP can be controlled

- most often associated with a memory operations in code like copying a string or moving data that accidentally overwrites other existing data in an unintended area of memory

- always check for bad characters that could cause the buffer overflow to be terminated early
	- look into the hex dump of where the bad characters were overflowing and see if any of them caused the buffer to terminate
		- if so sequential remove the bad characters to ensure the buffer can be properly written to
	- Common bad characters: 
		- 0x00 -> null byte 
		- Â 0x0A -> (HTTP) line feed
		- 0x0D -> (HTTP) line return

- [Mona](https://github.com/corelan/mona) extension for immunity debugger allows to search the entirety of a programs address space 

- main mode of discovery is fuzzing
	- looking for application crashes
- generally want to fuzz any input field the application offered

- Have to know exactly which part of the buffer is landing in the EIP register
	- 2 Methods:
		- **Binary Tree Analysis** -> splitting identified size of crash-causing buffer in half with two characters recursively until the exact address is identified
			- i.e. if the crash causing buffer was 800 chars, 400 A's and 400 B's would be sent in the same payload. If overwritten by B's, then that portion of the buffer would be split into 200 B's and 200 C's, etc. until we reach the exact bytes are identified that are overwriting the buffer. 
		- **Unique Pattern Iteration** -> uses a ruby script to generate unique sequence of 4 byte chunks equal to the size of the crash-causing buffer identified
			- this allows an easier way to identify exactly where the overwrite occurs according to which unique string of chars is written to EIP
			- ```/usr/share/metasploit-framework/tools/exploit/msf-pattern_create.rb -l [crash-causing buff size]```
			- ```/usr/share/metasploit-framework/tools/exploit/msf-pattern_offset.rb -l [crash-causing buffer] -q [hex representation overwrote to EIP]```






